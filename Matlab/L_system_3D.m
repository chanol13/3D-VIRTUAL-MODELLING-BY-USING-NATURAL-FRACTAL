function L_system_3D

% L_SYSTEM_3D simulates the L-system or string-rewriting-system
% in 3 dimensions.
% The recursive principle is the following:
%
%   axiom: initial string
%       |
%       |
%       -----> input string -----> production rules ----
%                   ^                                   |
%                   |                                   |
%                   --------output string <-------------
%
% The construction rules can be specified/changed in the file, as 
% well as the initial string and the number of iterations.
%
% The results are plotted with a chosen angle between the axioms
% and a chosen length of each axiom.
% Brackets '[' save the current position and angle, ']' returns
% to the saved position.
%
% The default setting draws a 'branch', a tree-like structure
% plotted with the colours brown and green with 4 iterations.

% This file was generated by students as a partial fulfillment 
% for the requirements of the course "Fractals", Winter term
% 2004/2005, Stuttgart University.	
	
% Author : Marko Grob, Wiebke Heidelberg
% Date   : Feb 2005
% Version: 1.0

clear all;


% 0. PART - INPUT VARIABLES
%============================

% input rules for the construction of the picture
rule(1).vorher = 'F';
rule(1).danach = 'F[-&\G][\++&G]||F[--&/G][+&G]'; 
rule(2).vorher = 'G';
rule(2).danach = 'F[+G][-G]F[+G][-G]FG' ;

n_Rules = length(rule);

% angle a: '+' = rotate anticlockwise, rotation matrix R_U(a);
%          '-' = rotate clockwise, rotation matrix R_U(-a).
%          '&' = grade downwards, rotation matrix R_L(a).
%          '^' = grade upwards, rotation matrix R_L(-a).
%          '\' = roll anticlockwise, rotation matrix R_H(a).
%          '/' = roll clockwise, rotation matrix R_H(-a).
%          '|' = turn around, rotation matrix R_H(180).
a = 22.5; % degrees (angle)

% lengths of the lines F and G
length_F = 1;
length_G = .75;


% starting string
axiom = 'F';

% iterations (choose only from 1 to 7, >= 8 critical, 
% depends on the string and on the computer !!
n_Repeats = 3;

% DO NOT CHANGE THIS VALUES
xT = 0;
yT = 0;
zT = 0;
hT = [1 0 0];
lT = [0 1 0];
uT = [0 0 1];
a = a/180*pi ; % deg -> rad

% THESE MATRICES MUSTN'T BE CHANGED AS WELL
% rotation matrix R_U(a) 
Rup = [ cos(a)   sin(a)  0; ...
        -sin(a)  cos(a)  0; ...
        0        0       1];
       
Rum = [ cos(-a)   sin(-a)  0; ...
        -sin(-a)  cos(-a)  0; ...
        0         0        1];
       
% rotation matrix R_L(a) 
Rlp = [ cos(a)  0  -sin(a); ...
        0       1  0; ...
        sin(a)  0  cos(a)];
 
Rlm = [ cos(-a)  0  -sin(-a); ...
        0        1  0; ...
        sin(-a)  0  cos(-a)];
 
% rotation matrix R_H(-a)
Rhp = [ 1  0       0; ...   
        0  cos(a)  -sin(a); ...
        0  sin(a)  cos(a)];

Rhm = [ 1  0        0; ...   
        0  cos(-a)  -sin(-a); ...
        0  sin(-a)  cos(-a)];

% rotation matrix R_H(180)
Rbk = [ -1  0   0; ...
        0   -1  0; ...
        0   0   1];

    
% 1. PART - CALCULATE THE STRING
%=================================

for i = 1:n_Repeats
    % a single letter (axiom)
    axiomINcells = cellstr(axiom');
    for j = 1:n_Rules
        % find all occurrences of that axiom
        hit = strfind(axiom, rule(j).vorher);
        if (length(hit) >= 1)
            for k = hit
                % perform the rule 
                % (replace 'vorher' by 'nachher')
                axiomINcells{k} = rule(j).danach;
            end
        end
    end
    axiom = [];
    for j = 1:length(axiomINcells)
        % put all strings together
        axiom = [axiom, axiomINcells{j}];
    end
end


% 2. PART - PLOT
%=====================

stkPtr = 1;
figure(1)
clf
hold on
vNF = 1; 
vNG = 1;
for i = 1:length(axiom)
    cmdT = axiom(i);
    switch cmdT
    % It is possible to add multiple cases here
    % in order to expand the program.
    case 'F'
        % how to plot a 'F' line
        newxT = xT + length_F*hT(1);
        newyT = yT + length_F*hT(2);
        newzT = yT + length_F*hT(3);
        line([xT newxT],[yT newyT],[zT newzT], 'color',[.5 .4 0], 'linewidth',2);
        vertsF{vNF} = [xT yT zT ; newxT newyT newzT];
        vNF = vNF +1;
        xT = newxT;
        yT = newyT;
        zT = newzT;
    case 'G'
        % how to plot a 'G' line
        newxT = xT + length_G*hT(1);
        newyT = yT + length_G*hT(2);
        newzT = yT + length_G*hT(3);
        line([xT newxT],[yT newyT],[zT newzT], 'color',[0 1 0], 'linewidth',2);
        vertsG{vNG} = [xT yT zT ; newxT newyT newzT];
        vNG = vNG +1;
        xT = newxT;
        yT = newyT;
        zT = newzT;
    case '+'
        % rotate anticlockwise
        hT = hT * Rup;
        lT = lT * Rup;
        uT = uT * Rup;
    case '-'
        % rotate clockwise
        hT = hT * Rum;
        lT = lT * Rum;
        uT = uT * Rum;
    case '&'
        % grade downwards
        hT = hT * Rlp;
        lT = lT * Rlp;
        uT = uT * Rlp;
    case '^'
        % grade upwards
        hT = hT * Rlm;
        lT = lT * Rlm;
        uT = uT * Rlm;
    case '\'
        % roll anticlockwise
        hT = hT * Rhp;
        lT = lT * Rhp;
        uT = uT * Rhp;
    case '/'
        % roll clockwise
        hT = hT * Rhm;
        lT = lT * Rhm;
        uT = uT * Rhm;
    case '|'
        % turn around
        hT = hT * Rbk;
        lT = lT * Rbk;
        uT = uT * Rbk;
    case '[' 
        % save the current position and push on the stack
        stack(stkPtr).xT = xT ;
        stack(stkPtr).yT = yT ;
        stack(stkPtr).zT = zT ;
        stack(stkPtr).hT = hT ;
        stack(stkPtr).lT = lT ;
        stack(stkPtr).uT = uT ;
        stkPtr = stkPtr +1 ;
    case ']' 
        % pop on the stack and return to the saved position 
        stkPtr = stkPtr -1 ;
        xT = stack(stkPtr).xT ;
        yT = stack(stkPtr).yT ;
        zT = stack(stkPtr).zT ;
        hT = stack(stkPtr).hT ;
        lT = stack(stkPtr).lT ;
        uT = stack(stkPtr).uT ;
    otherwise
        disp('error');
        return
    end
    % draw now
end

% make the first plot pretty
daspect([1 1 1]);
view(-70,70);
box on;
rotate3d on;

% make the second plot even prettier
figure(2);
clf;
daspect([1 1 1]);
Nsides = 8;
hsF = streamtube(vertsF,.3,[1,Nsides]);
set(hsF,'cdata',cat(3,.7*ones(2,Nsides+1), .7*ones(2,Nsides+1),zeros(2,Nsides+1)))

hsG = streamtube(vertsG,.2,[1,Nsides]);
set(hsG,'cdata',cat(3,zeros(2,Nsides+1), ones(2,Nsides+1),zeros(2,Nsides+1)))

axis tight
shading interp;
view(3);
camlight; lighting gouraud;
box on;
rotate3d on;